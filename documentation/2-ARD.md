# **Architecture Requirements Document (ARD)**

## **1. Introducci√≥n**

### **1.1 Prop√≥sito del Documento**  
El prop√≥sito de este **Architecture Requirements Document (ARD)** es proporcionar una descripci√≥n detallada de la arquitectura del **MVP del Sistema de Agendamiento de Citas**. Este documento servir√° como referencia para el equipo de desarrollo, asegurando que el dise√±o y la implementaci√≥n del sistema sigan una estructura s√≥lida, escalable y alineada con los objetivos del negocio.  

### **1.2 Alcance de la Arquitectura**  
El alcance de este documento est√° limitado a la **arquitectura del MVP**, considerando los siguientes aspectos:  
- Implementaci√≥n de una plataforma de **agendamiento de citas** entre pacientes y profesionales.  
- Gesti√≥n de disponibilidad **manual** por parte de los profesionales.  
- Notificaciones por **correo electr√≥nico** para confirmaciones y recordatorios de citas.  
- Uso de tecnolog√≠as seleccionadas:  
  - **Backend:** NestJS  
  - **Frontend:** NextJS  
  - **Base de Datos:** PostgreSQL  
- Despliegue en un entorno de **alta disponibilidad** con enfoque en escalabilidad b√°sica.  

**Exclusiones del Alcance:**  
- No se abordar√° la integraci√≥n con **pasarelas de pago** ni con **calendarios externos**.  
- No se incluir√°n funcionalidades avanzadas como **reportes y m√©tricas**.  
- No se implementar√° un sistema de autenticaci√≥n de usuarios en esta fase.  

### **1.3 Objetivos y Consideraciones Claves**  
Los objetivos de la arquitectura del MVP incluyen:  
‚úÖ **Simplicidad y rapidez en la implementaci√≥n:** Dise√±ar un sistema ligero y funcional en el menor tiempo posible.  
‚úÖ **Escalabilidad futura:** Aunque es un MVP, la arquitectura debe permitir futuras mejoras sin cambios disruptivos.  
‚úÖ **Alta disponibilidad:** Garantizar un **99% de tiempo operativo**, asegurando confiabilidad en la gesti√≥n de citas.  
‚úÖ **Seguridad de los datos:** Cumplir con las mejores pr√°cticas en protecci√≥n de informaci√≥n personal y privacidad.  
‚úÖ **Facilidad de uso:** Asegurar que la experiencia de usuario sea intuitiva y accesible, cumpliendo con est√°ndares **WCAG**.  

---


## **2. Arquitectura General**  

### **2.1 Visi√≥n General del Sistema**  
El sistema de agendamiento de citas es una aplicaci√≥n **web** dise√±ada para facilitar la gesti√≥n de citas entre **pacientes y profesionales**. La arquitectura sigue un enfoque basado en **microservicios ligeros**, permitiendo modularidad y facilidad de escalabilidad en futuras iteraciones.  

El sistema se compone de tres capas principales:  
1. **Capa de Presentaci√≥n (Frontend - NextJS)**: Interfaz web accesible para pacientes y profesionales.  
2. **Capa de Aplicaci√≥n (Backend - NestJS)**: API REST responsable de la l√≥gica de negocio y gesti√≥n de datos.  
3. **Capa de Datos (PostgreSQL)**: Base de datos relacional encargada de almacenar informaci√≥n de citas y usuarios.  

üìå **Principios Arquitect√≥nicos Aplicados:**  
‚úÖ **Separaci√≥n de responsabilidades:** Distinci√≥n clara entre presentaci√≥n, l√≥gica y datos.  
‚úÖ **Escalabilidad modular:** Capacidad para agregar nuevas funcionalidades sin afectar la estabilidad.  
‚úÖ **Seguridad y disponibilidad:** Protecci√≥n de datos y operaci√≥n confiable con redundancia.  

### **2.2 Diagrama de Contexto (C4 - Nivel 1)**  
A continuaci√≥n, se presenta un **Diagrama de Contexto (Nivel 1)** que ilustra la relaci√≥n del sistema con sus usuarios y servicios externos:

```mermaid
graph TD;
    U1[Paciente] -->|Usa| S[Sistema de Agendamiento de Citas]
    U2[Profesional] -->|Usa| S
    S -->|Env√≠a correos| E[Servicio de Notificaci√≥n]
    S -->|Consulta y almacena| DB[(PostgreSQL)]
```

üìå **Explicaci√≥n:**  
- Los **pacientes y profesionales** interact√∫an con el sistema a trav√©s de la interfaz web.  
- El sistema se comunica con un **servicio de correo** para enviar notificaciones.  
- La base de datos almacena y recupera informaci√≥n sobre usuarios, citas y disponibilidad.  

### **2.3 Principales Componentes del Sistema**  
El sistema est√° compuesto por los siguientes m√≥dulos clave:

| **Componente**       | **Descripci√≥n** |
|----------------------|------------------------------------------------------|
| **Interfaz Web (NextJS)** | Plataforma para que los usuarios gestionen sus citas. |
| **API Backend (NestJS)** | Exposici√≥n de endpoints REST para manejar la l√≥gica del sistema. |
| **Base de Datos (PostgreSQL)** | Almac√©n de datos estructurados para la gesti√≥n de citas y usuarios. |
| **Servicio de Notificaciones** | Mecanismo de env√≠o de correos de confirmaci√≥n y recordatorios. |

### **2.4 Decisiones Arquitect√≥nicas Claves**  
üìå **Decisiones tomadas:**  
- Se opt√≥ por una **arquitectura basada en APIs REST** en lugar de GraphQL para simplicidad en el desarrollo del MVP.  
- Uso de **NextJS** en el frontend por su capacidad de renderizado h√≠brido y su compatibilidad con futuras mejoras.  
- Se eligi√≥ **PostgreSQL** debido a su estabilidad, capacidad de escalabilidad y soporte de integridad referencial.  
- Se dej√≥ abierta la posibilidad de migrar a **una arquitectura basada en eventos** en futuras iteraciones para mejorar el procesamiento as√≠ncrono.  

üìå **Trade-offs identificados:**  
- No se implementar√° autenticaci√≥n en el MVP, lo que limita la personalizaci√≥n de la experiencia del usuario.  
- Se usar√° una estructura monol√≠tica en el backend inicialmente, con la posibilidad de modularizar servicios en el futuro.  

---


# **3. Dise√±o de Componentes**  

## **3.1 Backend**  

El backend del sistema sigue una arquitectura basada en principios de **Domain-Driven Design (DDD)**, con una implementaci√≥n estructurada mediante **Hexagonal Architecture**, **Clean Architecture**, y utilizando enfoques como **Vertical Slicing** y **Screaming Architecture** para mejorar la mantenibilidad y escalabilidad del c√≥digo.  

### **3.1.1 Principios y Arquitecturas Aplicadas**  

‚úÖ **Domain-Driven Design (DDD)**  
- Se han agregado **m√≥dulos espec√≠ficos** para la gesti√≥n de disponibilidad y validaci√≥n de reglas de negocio.  
- Cada m√≥dulo encapsula su l√≥gica y evita dependencias innecesarias.  

‚úÖ **Hexagonal Architecture**  
- Se han definido **puertos y adaptadores** para manejar la **actualizaci√≥n de disponibilidad en tiempo real**.  
- Implementaci√≥n de adaptadores para la integraci√≥n con **servicios de mensajer√≠a en tiempo real**.  

‚úÖ **Vertical Slicing**  
- Separaci√≥n modular de **Citas**, **Disponibilidad**, **Notificaciones** y **Reglas de Negocio**.  
- Cada funcionalidad se encapsula en su propio m√≥dulo para garantizar mantenibilidad y escalabilidad.  

‚úÖ **Event-Driven Architecture**  
- Se han introducido eventos internos para gestionar la **actualizaci√≥n de disponibilidad** y evitar conflictos en la asignaci√≥n de citas.  
- Uso de **mensajes en tiempo real** para reflejar cambios en la agenda de los profesionales.  

üìå **Patrones de Dise√±o Implementados:**  

| **Patr√≥n** | **Descripci√≥n** |
|------------|------------------------------------------------------|
| **Repository Pattern** | Separa la l√≥gica de acceso a datos de la l√≥gica de negocio. |
| **Observer Pattern** | Implementado para **actualizaci√≥n en tiempo real de la disponibilidad** de los profesionales. |
| **Event-Driven Architecture** | Manejo de eventos para reflejar cambios de disponibilidad sin bloquear operaciones cr√≠ticas. |
| **Factory Pattern** | Creaci√≥n de objetos complejos en los casos de uso de citas y disponibilidad. |

---

### **3.1.2 Stack Tecnol√≥gico y Herramientas**  
- **Lenguaje:** TypeScript  
- **Framework:** NestJS  
- **ORM:** Prisma (para gestionar la base de datos con PostgreSQL)  
- **Validaci√≥n:** Zod (validaci√≥n de datos)  
- **Mensajer√≠a/Colas:** RabbitMQ (para procesamiento as√≠ncrono en el futuro)  
- **Autenticaci√≥n:** No incluida en el MVP, pero se prev√© JWT en versiones futuras  

---

### **3.1.3 Patrones de Dise√±o Implementados**  
| **Patr√≥n** | **Descripci√≥n** |
|------------|------------------------------------------------------|
| **Repository Pattern** | Separa la l√≥gica de acceso a datos de la l√≥gica de negocio. |
| **Dependency Injection** | Se utiliza el m√≥dulo de inyecci√≥n de dependencias de NestJS para mejorar testabilidad y modularidad. |
| **Factory Pattern** | Se usa para la creaci√≥n de objetos complejos en los casos de uso. |
| **Observer Pattern** | Utilizado para gestionar eventos internos, como notificaciones. |

---

## **3.2 Frontend**  

El frontend est√° desarrollado con **Next.js**, aprovechando su flexibilidad en **Server-Side Rendering (SSR)** y **Static Site Generation (SSG)** para mejorar la experiencia del usuario.  

### **3.2.1 Principales Flujos de Usuario**  
El sistema cuenta con los siguientes **flujos principales**, asegurando una experiencia fluida e intuitiva.  

| **Flujo** | **Descripci√≥n** |
|------------|------------------------------------------------------|
| **Appointment Booking** | El usuario selecciona un profesional, consulta la disponibilidad y agenda una cita. |
| **Appointment Management** | El usuario puede modificar o cancelar citas seg√∫n las reglas establecidas. |
| **Availability Management** | Los profesionales pueden definir sus horarios disponibles. |
| **Notifications Handling** | El sistema env√≠a correos electr√≥nicos de confirmaci√≥n y recordatorio de citas. |

üìå **Cada flujo de usuario se implementar√° con React Hooks y Context API para la gesti√≥n del estado global.**  

---

### **3.2.2 Componentes Claves del Frontend**  
üìå **Principales Componentes React:**  
- **AppointmentForm:** Formulario para agendar citas.  
- **AvailabilityManager:** Interfaz para que los profesionales configuren su disponibilidad.  
- **NotificationBanner:** Muestra confirmaciones y recordatorios de citas.  
- **UserDashboard:** Panel de control para pacientes y profesionales.  

üìå **Estado Global:**  
- Se usar√° **React Context API o Zustand** para manejar datos compartidos.  

---

### **3.3 Base de Datos**  

üìå **Modelo Relacional Actualizado:**  

```mermaid
erDiagram
    %% Tablas del esquema `auth` de Supabase
    AUTH_USERS {
        uuid id PK
        text email UK
        text encrypted_password
        json raw_user_meta_data
        timestamp created_at
        timestamp updated_at
    }
    
    AUTH_IDENTITIES {
        uuid id PK
        uuid user_id FK
        text provider
        text provider_id UK
    }

    %% Tablas del esquema `public` para la funcionalidad del MVP
    USERS {
        uuid id PK
        uuid auth_user_id FK
        text first_name
        text last_name
        text role "ENUM:PATIENT,PROFESSIONAL"
        timestamp created_at
        timestamp updated_at
    }
    
    APPOINTMENTS {
        uuid id PK
        uuid patient_id FK
        uuid professional_id FK
        timestamp appointment_date
        text status "ENUM:SCHEDULED,CANCELLED,COMPLETED"
        timestamp created_at
        timestamp updated_at
    }
    
    AVAILABILITY {
        uuid id PK
        uuid professional_id FK
        timestamp available_date
        time start_time
        time end_time
        boolean is_booked
        timestamp created_at
        timestamp updated_at
    }
    
    NOTIFICATIONS {
        uuid id PK
        uuid user_id FK
        uuid appointment_id FK
        text type "ENUM:CONFIRMATION,REMINDER,CANCELLATION"
        boolean is_sent
        timestamp sent_at
    }
    
    AUDIT_LOGS {
        uuid id PK
        uuid user_id FK
        text action
        json metadata
        timestamp created_at
    }
    
    CONFIGURATION {
        uuid id PK
        text key UK
        text value
        timestamp updated_at
    }
    
    %% Relaciones entre tablas
    AUTH_USERS ||--o{ USERS : "authenticates"
    USERS ||--o{ APPOINTMENTS : "has as patient"
    USERS ||--o{ APPOINTMENTS : "has as professional"
    USERS ||--o{ AVAILABILITY : "manages"
    APPOINTMENTS ||--o{ NOTIFICATIONS : "triggers"
    USERS ||--o{ AUDIT_LOGS : "generates"
    USERS ||..o{ NOTIFICATIONS : "receives"
```

üìå **Explicaci√≥n del modelo de datos:**  

‚úÖ **Integraci√≥n con Supabase Auth**  
- `AUTH_USERS` almacena los datos de autenticaci√≥n gestionados por Supabase.  
- `AUTH_IDENTITIES` permite la vinculaci√≥n con proveedores de autenticaci√≥n externa (Google, GitHub, etc.).  
- `USERS` referencia a `AUTH_USERS` mediante `auth_user_id`, permitiendo la asociaci√≥n con perfiles internos en la aplicaci√≥n.  

‚úÖ **Usuarios y gesti√≥n de disponibilidad**  
- `USERS` diferencia entre **pacientes** y **profesionales** mediante el campo `role`.  
- `AVAILABILITY` almacena los horarios disponibles de los profesionales, con un campo `is_booked` para indicar si un horario ya est√° reservado.  

‚úÖ **Citas y notificaciones**  
- `APPOINTMENTS` gestiona las citas entre **pacientes y profesionales**, incluyendo estados (`SCHEDULED`, `CANCELLED`, `COMPLETED`).  
- `NOTIFICATIONS` est√° ligada a `APPOINTMENTS`, permitiendo el env√≠o de correos electr√≥nicos con estados `CONFIRMATION`, `REMINDER` y `CANCELLATION`.  

‚úÖ **Monitoreo y Configuraci√≥n del Sistema**  
- `AUDIT_LOGS` almacena acciones relevantes para la trazabilidad del sistema.  
- `CONFIGURATION` permite definir par√°metros clave como **restricciones de cancelaci√≥n/modificaci√≥n** y **horarios de atenci√≥n**.  

üìå **Estrategias de Indexaci√≥n y Optimizaci√≥n:**  

‚úÖ **√çndices Clave:**  
- **`appointment_date` en APPOINTMENTS**: Mejora el rendimiento de consultas sobre disponibilidad.  
- **`user_id` en NOTIFICATIONS y AUDIT_LOGS**: Facilita la recuperaci√≥n r√°pida de registros por usuario.  
- **`key` en CONFIGURATION**: Asegura consultas eficientes sobre par√°metros configurables del sistema.  

‚úÖ **Estrategias de Normalizaci√≥n y Integridad:**  
- **Estructura completamente normalizada**, eliminando redundancias en las relaciones.  
- **Claves for√°neas definidas** para garantizar integridad referencial en APPOINTMENTS, AVAILABILITY y NOTIFICATIONS.  
- **Soporte para auditor√≠a de cambios en AUDIT_LOGS**, asegurando trazabilidad en el sistema.  



### **3.4 Sistema de Notificaciones**  

üìå **Estrategia de Implementaci√≥n:**  
- **Notificaciones basadas en eventos**: Se activar√°n en funci√≥n de cambios en **citas y disponibilidad**.  
- **Integraci√≥n con Supabase**: Las notificaciones estar√°n asociadas a usuarios autenticados en `AUTH_USERS`.  
- **Mecanismo as√≠ncrono**: Se utilizar√° **Redis Pub/Sub o una cola en Supabase** para procesar los eventos sin afectar el rendimiento de la API principal.  

üìå **Eventos que activan una notificaci√≥n:**  
‚úÖ **Cita agendada:** Notificaci√≥n de confirmaci√≥n para el paciente y el profesional.  
‚úÖ **Modificaci√≥n de cita:** Notificaci√≥n con la actualizaci√≥n del horario.  
‚úÖ **Cancelaci√≥n de cita:** Notificaci√≥n inmediata sobre la cancelaci√≥n.  
‚úÖ **Recordatorios:**  
  - 24 horas antes de la cita.  
  - 1 hora antes de la cita.  
‚úÖ **Actualizaci√≥n de disponibilidad:** Si un profesional modifica su horario, se notificar√° a los pacientes con citas afectadas.  

üìå **Diagrama de Flujo del Env√≠o de Notificaciones**  

```mermaid
sequenceDiagram
    participant Patient as Paciente
    participant Professional as Profesional
    participant Backend as Backend API
    participant DB as Base de Datos
    participant Email as Servicio de Notificaciones

    Patient->>Backend: Agenda una cita
    Backend->>DB: Guarda la cita en la base de datos
    Backend->>Email: Env√≠a confirmaci√≥n a paciente y profesional
    Email-->>Patient: Recibe confirmaci√≥n de cita
    Email-->>Professional: Recibe confirmaci√≥n de cita

    Note over Backend: Se genera un evento en la cola de notificaciones

    Backend->>DB: Programa recordatorio 24h antes
    Backend->>DB: Programa recordatorio 1h antes
```

üìå **Integraci√≥n con el Modelo de Datos**  
- `NOTIFICATIONS` almacena un registro de cada notificaci√≥n enviada.  
- Relaci√≥n con `APPOINTMENTS` para notificaciones de citas.  
- Relaci√≥n con `USERS` para trazabilidad de notificaciones enviadas.  

üìå **Escalabilidad y Seguridad**  
‚úÖ **Estrategia de reintento**: Si una notificaci√≥n falla, se intentar√° reenviar hasta **tres veces** antes de registrar el error.  
‚úÖ **Registro de actividad**: Se documentar√°n los env√≠os exitosos y fallidos en `AUDIT_LOGS`.  
‚úÖ **Protecci√≥n contra spam**: Se limitar√° el n√∫mero de notificaciones enviadas por usuario en un per√≠odo determinado.  



---


# **4. Modelado de Datos**  


### **4.1 Esquema de Base de Datos**  

La base de datos del sistema est√° dise√±ada en **PostgreSQL con Supabase**, siguiendo un **modelo relacional** optimizado para la gesti√≥n eficiente de usuarios, citas y disponibilidad. Se ha aplicado **normalizaci√≥n completa** para evitar redundancias y garantizar integridad referencial.  

üìå **Caracter√≠sticas clave del modelo de datos:**  
‚úÖ **Integraci√≥n con Supabase Auth**: `AUTH_USERS` almacena la autenticaci√≥n y `USERS` gestiona la relaci√≥n con las funcionalidades de la aplicaci√≥n.  
‚úÖ **Uso de UUIDs** como identificadores primarios en todas las tablas para garantizar unicidad y escalabilidad.  
‚úÖ **√çndices en columnas de b√∫squeda frecuente** (`user_id`, `appointment_date`) para optimizar consultas.  
‚úÖ **Estrategia de retenci√≥n de datos**: Se establecen reglas en `CONFIGURATION` para gestionar pol√≠ticas de almacenamiento de notificaciones y logs.  
‚úÖ **Normalizaci√≥n completa**: Relaci√≥n entre entidades sin redundancia de datos.  

üìå **Actualizaci√≥n en el Diagrama Relacional**  

```mermaid
erDiagram
    %% Tablas del esquema `auth` de Supabase
    AUTH_USERS {
        uuid id PK
        text email UK
        text encrypted_password
        json raw_user_meta_data
        timestamp created_at
        timestamp updated_at
    }
    
    AUTH_IDENTITIES {
        uuid id PK
        uuid user_id FK
        text provider
        text provider_id UK
    }

    %% Tablas del esquema `public` para la funcionalidad del MVP
    USERS {
        uuid id PK
        uuid auth_user_id FK
        text first_name
        text last_name
        text role "ENUM:PATIENT,PROFESSIONAL"
        timestamp created_at
        timestamp updated_at
    }
    
    APPOINTMENTS {
        uuid id PK
        uuid patient_id FK
        uuid professional_id FK
        timestamp appointment_date
        text status "ENUM:SCHEDULED,CANCELLED,COMPLETED"
        timestamp created_at
        timestamp updated_at
    }
    
    AVAILABILITY {
        uuid id PK
        uuid professional_id FK
        timestamp available_date
        time start_time
        time end_time
        boolean is_booked
        timestamp created_at
        timestamp updated_at
    }
    
    NOTIFICATIONS {
        uuid id PK
        uuid user_id FK
        uuid appointment_id FK
        text type "ENUM:CONFIRMATION,REMINDER,CANCELLATION"
        boolean is_sent
        timestamp sent_at
    }
    
    AUDIT_LOGS {
        uuid id PK
        uuid user_id FK
        text action
        json metadata
        timestamp created_at
    }
    
    CONFIGURATION {
        uuid id PK
        text key UK
        text value
        timestamp updated_at
    }
    
    %% Relaciones entre tablas
    AUTH_USERS ||--o{ USERS : "authenticates"
    USERS ||--o{ APPOINTMENTS : "has as patient"
    USERS ||--o{ APPOINTMENTS : "has as professional"
    USERS ||--o{ AVAILABILITY : "manages"
    APPOINTMENTS ||--o{ NOTIFICATIONS : "triggers"
    USERS ||--o{ AUDIT_LOGS : "generates"
    USERS ||..o{ NOTIFICATIONS : "receives"
```

üìå **Explicaci√≥n de los cambios en la estructura de datos:**  
‚úÖ **Usuarios y autenticaci√≥n**  
- `AUTH_USERS` almacena credenciales y metadatos de Supabase.  
- `USERS` se enlaza con `AUTH_USERS` mediante `auth_user_id` para la gesti√≥n de pacientes y profesionales.  

‚úÖ **Gesti√≥n de disponibilidad y citas**  
- `AVAILABILITY` gestiona los horarios de los profesionales y su estado (`is_booked`).  
- `APPOINTMENTS` registra las citas entre pacientes y profesionales, asegurando integridad referencial.  

‚úÖ **Notificaciones y auditor√≠a**  
- `NOTIFICATIONS` almacena registros de confirmaciones, recordatorios y cancelaciones.  
- `AUDIT_LOGS` documenta cambios en el sistema con `metadata` en formato JSON.  

‚úÖ **Configuraci√≥n flexible**  
- `CONFIGURATION` almacena par√°metros del sistema como tiempos de cancelaci√≥n/modificaci√≥n y pol√≠ticas de retenci√≥n de datos.  


---


### **4.2 Entidades y Relaciones**  

El modelo de datos est√° compuesto por las siguientes entidades principales:  

| **Entidad** | **Descripci√≥n** |
|------------|------------------------------------------------------|
| **AUTH_USERS** | Gestionado por Supabase, almacena informaci√≥n de autenticaci√≥n de los usuarios. |
| **AUTH_IDENTITIES** | Relaciona a los usuarios con proveedores de autenticaci√≥n externa (Google, GitHub, etc.). |
| **USERS** | Informaci√≥n detallada de los usuarios, vinculado con `AUTH_USERS` para autenticaci√≥n. |
| **APPOINTMENTS** | Registra las citas entre pacientes y profesionales, con su respectivo estado. |
| **AVAILABILITY** | Gestiona la disponibilidad de los profesionales, asegurando horarios reservables. |
| **NOTIFICATIONS** | Almacena notificaciones enviadas a los usuarios, relacionadas con eventos de citas. |
| **AUDIT_LOGS** | Guarda un historial de acciones dentro del sistema para trazabilidad y seguridad. |
| **CONFIGURATION** | Permite parametrizar reglas del sistema, como restricciones de cancelaci√≥n. |


üìå **Explicaci√≥n de las relaciones:**  
‚úÖ **Autenticaci√≥n con Supabase**  
- `AUTH_USERS` se relaciona con `USERS` a trav√©s de `auth_user_id`, garantizando autenticaci√≥n segura.  
- `AUTH_IDENTITIES` vincula usuarios con autenticaci√≥n externa.  

‚úÖ **Gesti√≥n de disponibilidad y citas**  
- `USERS` diferencia entre **pacientes y profesionales** mediante el campo `role`.  
- `APPOINTMENTS` asocia pacientes con profesionales y almacena el estado de la cita.  
- `AVAILABILITY` almacena los horarios de los profesionales y su disponibilidad.  

‚úÖ **Notificaciones y auditor√≠a**  
- `NOTIFICATIONS` almacena confirmaciones, recordatorios y cancelaciones.  
- `AUDIT_LOGS` documenta cambios en el sistema para trazabilidad.  

‚úÖ **Configuraci√≥n din√°mica**  
- `CONFIGURATION` almacena reglas clave del sistema, permitiendo ajustes sin modificar c√≥digo.  


---

### **4.3 Normalizaci√≥n y Optimizaci√≥n**  

üìå **4.3.1 Estrategia de Normalizaci√≥n**  
El modelo sigue la **Tercera Forma Normal (3NF)**, asegurando que:  
‚úÖ **No haya redundancia de datos**, separando autenticaci√≥n (`AUTH_USERS`) de los perfiles (`USERS`).  
‚úÖ **Cada columna almacene un √∫nico valor at√≥mico**, evitando listas dentro de atributos.  
‚úÖ **Las relaciones entre entidades est√©n correctamente definidas con claves for√°neas**, garantizando integridad referencial.  

üìå **Ajustes clave en la normalizaci√≥n:**  
- `USERS.auth_user_id` referencia `AUTH_USERS.id`, evitando duplicaci√≥n de datos de autenticaci√≥n.  
- `APPOINTMENTS` separa `patient_id` y `professional_id` para clarificar las relaciones sin redundancia.  
- `AVAILABILITY` almacena la disponibilidad de profesionales sin datos innecesarios sobre citas.  

üìå **4.3.2 Optimizaci√≥n del Rendimiento**  

‚úÖ **√çndices Clave:**  
- **`appointment_date` en APPOINTMENTS**: Acelera b√∫squedas de citas por fecha.  
- **`user_id` en NOTIFICATIONS y AUDIT_LOGS**: Optimiza consultas relacionadas con usuarios.  
- **`key` en CONFIGURATION**: Facilita la consulta eficiente de par√°metros del sistema.  

‚úÖ **Estrategias de Escalabilidad:**  
- **Uso de UUIDs** en todas las claves primarias, asegurando distribuci√≥n uniforme en la base de datos.  
- **Particionamiento de tablas en futuras versiones** para manejar grandes vol√∫menes de datos (ejemplo: `AUDIT_LOGS`).  
- **Cache en consultas de lectura frecuente** mediante **Redis** para mejorar tiempos de respuesta.  

‚úÖ **Gesti√≥n de Retenci√≥n de Datos:**  
- **Borrado autom√°tico de logs** seg√∫n la pol√≠tica almacenada en `CONFIGURATION`.  
- **Depuraci√≥n de notificaciones antiguas** con cron jobs para mantener rendimiento √≥ptimo.  


---


# **5. Seguridad y Privacidad**  

## **5.1 Principios de Seguridad Aplicados**  

La seguridad del sistema se basa en las mejores pr√°cticas para proteger la informaci√≥n de los usuarios y garantizar la integridad de los datos. Se han definido los siguientes principios clave:  

üìå **Principios de Seguridad en el Desarrollo:**  
‚úÖ **Principio de Menor Privilegio:** Cada usuario solo tendr√° acceso a los datos y funciones necesarias.  
‚úÖ **Defensa en Profundidad:** Se aplican m√∫ltiples capas de seguridad para mitigar riesgos.  
‚úÖ **Principio de Seguridad por Dise√±o:** La seguridad es considerada desde la arquitectura, no como un agregado posterior.  
‚úÖ **Reglas de Validaci√≥n Rigurosas:** Se validan y sanitizan todos los datos de entrada para evitar inyecciones y ataques comunes.  

---

## **5.2 Protecci√≥n de Datos Personales**  

El sistema manejar√° informaci√≥n sensible de los usuarios, por lo que se han implementado las siguientes medidas para garantizar la privacidad de los datos:  

üìå **Medidas de Protecci√≥n:**  
- **Cifrado en Reposo:** Los datos sensibles almacenados en la base de datos (ej. correos electr√≥nicos) estar√°n cifrados con **AES-256**.  
- **Cifrado en Tr√°nsito:** Todo el tr√°fico de datos entre el cliente y el servidor estar√° cifrado mediante **TLS 1.3**.  
- **Cumplimiento con GDPR & OWASP:** Se seguir√°n recomendaciones de seguridad para proteger datos personales.  
- **Pol√≠tica de Retenci√≥n de Datos:** Se definir√°n reglas para eliminar o anonimizar datos obsoletos.  

---

### **5.3 Controles de Acceso y Autenticaci√≥n**  

üìå **Autenticaci√≥n con Supabase Auth**  
‚úÖ **Usuarios gestionados en Supabase Auth (`AUTH_USERS`)**, vinculados con perfiles en `USERS`.  
‚úÖ **Autenticaci√≥n con JWT**, permitiendo acceso seguro a la API.  
‚úÖ **Integraci√≥n con OAuth2 y proveedores externos** a trav√©s de `AUTH_IDENTITIES` (Google, GitHub, etc.).  

üìå **Autorizaci√≥n Basada en Roles (RBAC)**  
‚úÖ **Roles definidos en `USERS.role`**:  
   - `PATIENT`: Solo puede gestionar sus propias citas.  
   - `PROFESSIONAL`: Puede gestionar su disponibilidad y citas asignadas.  
   - **Futuro:** Se puede agregar un rol `ADMIN` para auditor√≠a y configuraci√≥n.  

üìå **Reglas de Seguridad Aplicadas**  
‚úÖ **Row Level Security (RLS) en Supabase**:  
   - Los pacientes solo pueden acceder a **sus propias citas**.  
   - Los profesionales solo pueden gestionar **su disponibilidad y citas asignadas**.  
   - No se permite acceso directo a `AUTH_USERS`, solo a trav√©s del backend.  

‚úÖ **Protecci√≥n de Rutas en la API**  
   - Middleware de **verificaci√≥n de JWT** en cada solicitud autenticada.  
   - Validaci√≥n de **permisos de usuario** antes de ejecutar operaciones sensibles.  

üìå **Ejemplo de Pol√≠tica RLS en `APPOINTMENTS`**  
```sql
CREATE POLICY "Patients can access their own appointments"
ON public.appointments
FOR SELECT USING (auth.uid() = patient_id);

CREATE POLICY "Professionals can access their assigned appointments"
ON public.appointments
FOR SELECT USING (auth.uid() = professional_id);
```

---

## **5.4 Estrategias contra Ataques Comunes**  

Para proteger el sistema contra amenazas externas, se han implementado las siguientes estrategias de mitigaci√≥n:  

| **Ataque Potencial** | **Medidas de Protecci√≥n** |
|--------------------|----------------------------------|
| **SQL Injection** | Uso de **ORM Prisma**, validaci√≥n estricta de entradas y consultas parametrizadas. |
| **Cross-Site Scripting (XSS)** | Escapado de datos en el frontend y sanitizaci√≥n de entradas con **Zod**. |
| **Cross-Site Request Forgery (CSRF)** | Implementaci√≥n de tokens CSRF en futuras versiones. |
| **Denegaci√≥n de Servicio (DoS/DDoS)** | Limitaci√≥n de peticiones con **rate-limiting** en la API. |
| **Exposici√≥n de Datos Sensibles** | No se almacenar√°n contrase√±as en texto plano, y se usar√° **bcrypt** en futuras versiones. |

---

# **6. Escalabilidad y Disponibilidad**  

## **6.1 Estrategias de Escalabilidad**  

El sistema debe ser capaz de manejar un crecimiento progresivo en la cantidad de usuarios y transacciones sin comprometer el rendimiento. Para ello, se han definido las siguientes estrategias de escalabilidad:  

üìå **Escalabilidad Horizontal y Vertical:**  
‚úÖ **Escalabilidad Horizontal:** Se pueden a√±adir m√°s instancias de los servicios backend y frontend para distribuir la carga.  
‚úÖ **Escalabilidad Vertical:** Aumento de recursos en el servidor de base de datos en funci√≥n del crecimiento del sistema.  

üìå **Bases de Datos Optimizadas para Escalabilidad:**  
‚úÖ **Uso de Prisma ORM** para manejar grandes vol√∫menes de datos con consultas optimizadas.  
‚úÖ **Indexaci√≥n Estrat√©gica** en columnas de b√∫squeda frecuente (`appointment_date`, `user_id`).  
‚úÖ **Particionamiento de Tablas** en futuras versiones para optimizar consultas de gran escala.  

üìå **Desacoplamiento de Servicios:**  
‚úÖ Uso de **colas de mensajes (RabbitMQ o Redis Pub/Sub)** en versiones futuras para manejar procesos as√≠ncronos como notificaciones.  
‚úÖ Microservicios planificados a futuro para manejar m√≥dulos de citas y disponibilidad por separado.  

---

## **6.2 Balanceo de Carga y Distribuci√≥n de Tr√°fico**  

Para garantizar una experiencia de usuario fluida, se implementar√°n estrategias de distribuci√≥n de tr√°fico.  

üìå **Estrategias de Balanceo de Carga:**  
‚úÖ **Reverse Proxy con Nginx o Traefik** para distribuir tr√°fico entre m√∫ltiples instancias del backend.  
‚úÖ **Load Balancer (AWS ALB o Nginx HA)** para repartir tr√°fico entre servidores en futuras iteraciones.  

üìå **CDN para el Frontend:**  
‚úÖ Uso de **Vercel o Cloudflare CDN** para servir archivos est√°ticos y reducir latencia en el frontend.  

üìå **Optimizaci√≥n de Respuesta en la API:**  
‚úÖ Uso de **caching en Redis** para almacenar respuestas frecuentes y reducir carga en la base de datos.  
‚úÖ **Rate Limiting** en la API para evitar abuso del sistema y ataques DoS.  

---

### **6.3 Monitoreo y Mantenimiento**  

üìå **Estrategias de Monitoreo:**  
‚úÖ **Registro de eventos de autenticaci√≥n** en **Supabase Auth**, incluyendo intentos fallidos y logins exitosos.  
‚úÖ **Monitoreo de consultas SQL en PostgreSQL** con logs activados en Supabase para identificar cuellos de botella.  
‚úÖ **Alertas autom√°ticas para eventos cr√≠ticos**, como m√∫ltiples intentos fallidos de login o errores en la API.  

üìå **Herramientas Utilizadas:**  
‚úÖ **Supabase Logs**: Seguimiento en tiempo real de eventos de autenticaci√≥n y cambios en la base de datos.  
‚úÖ **Prometheus + Grafana**: Visualizaci√≥n de m√©tricas de rendimiento de la API.  
‚úÖ **Sentry o Datadog**: Captura y an√°lisis de errores en frontend y backend.  
‚úÖ **Winston + Supabase Storage**: Almacenamiento de logs hist√≥ricos en Supabase para auditor√≠a.  

üìå **Estrategia de Auditor√≠a de Accesos:**  
‚úÖ **Registro en `AUDIT_LOGS`** de eventos relevantes, incluyendo:  
   - Creaci√≥n, modificaci√≥n y cancelaci√≥n de citas.  
   - Cambios en la disponibilidad de profesionales.  
   - Intentos de acceso no autorizados o fallos de autenticaci√≥n.  

üìå **Ejemplo de Registro de Auditor√≠a en `AUDIT_LOGS`**  
```json
{
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "action": "LOGIN_SUCCESS",
  "metadata": {
    "ip_address": "192.168.1.1",
    "device": "Chrome on Windows"
  },
  "created_at": "2024-06-01T12:00:00Z"
}
```

üìå **Mecanismo de Recuperaci√≥n ante Fallos:**  
‚úÖ **Auto-escalado en Supabase**: Se activa autom√°ticamente si la base de datos alcanza un umbral de uso elevado.  
‚úÖ **Respaldo de base de datos**: Backups autom√°ticos configurados en Supabase con restauraci√≥n en menos de 15 minutos.  
‚úÖ **Tolerancia a fallos en la API**: Implementaci√≥n de **circuit breakers** y reintentos autom√°ticos en solicitudes fallidas.  


---


# **7. Diagramas de Arquitectura**  

## **7.1 Casos de Uso**  

El siguiente diagrama representa los **principales casos de uso** del sistema, detallando las interacciones entre los usuarios y el sistema de agendamiento de citas.  

```mermaid
graph TD;
    A[Paciente] -->|Agenda Cita| B(Sistema de Agendamiento)
    A -->|Cancela Cita| B
    A -->|Modifica Cita| B
    B -->|Env√≠a Notificaci√≥n| C[Servicio de Notificaciones]
    B -->|Actualiza Disponibilidad| D[Profesional]
    D -->|Configura Horario| B
    B -->|Consulta Base de Datos| E[(PostgreSQL)]
```

üìå **Explicaci√≥n:**  
- **El paciente** puede agendar, modificar o cancelar citas.  
- **El sistema** actualiza la base de datos y env√≠a notificaciones a los usuarios.  
- **El profesional** configura su disponibilidad, que es utilizada por el sistema para la gesti√≥n de citas.  

---

## **7.2 Diagramas C4 (Niveles 1 y 2)**  

### **Diagrama C4 - Nivel 1 (Contexto del Sistema)**  

```mermaid
graph TD;
    U1[Paciente] -->|Usa| S[Sistema de Agendamiento]
    U2[Profesional] -->|Usa| S
    S -->|Env√≠a correos| E[Servicio de Notificaci√≥n]
    S -->|Consulta y almacena| DB[(PostgreSQL)]
```

üìå **Explicaci√≥n:**  
- Representa c√≥mo el **sistema** interact√∫a con los usuarios y servicios externos.  
- Se considera **PostgreSQL** como base de datos y un servicio externo para **notificaciones por correo**.  

### **Diagrama C4 - Nivel 2 (Componentes del Sistema)**  

```mermaid
graph TD;
    Frontend -->|Consume API| Backend
    Backend -->|Consulta y guarda| DB[(PostgreSQL)]
    Backend -->|Env√≠a correos| Notifications[Servicio de Notificaciones]
    Backend -->|Maneja disponibilidad| Availability[Disponibilidad de Profesionales]
```

üìå **Explicaci√≥n:**  
- **Frontend:** Next.js se comunica con la API para realizar operaciones.  
- **Backend:** NestJS gestiona la l√≥gica de negocio y acceso a datos.  
- **Base de datos:** PostgreSQL almacena usuarios, citas y disponibilidad.  
- **Servicio de Notificaciones:** Maneja el env√≠o de correos electr√≥nicos.  

---

### **7.3 Modelo de Base de Datos ‚Äì Implementaci√≥n en Backend**  

üìå **Interacci√≥n del Backend con la Base de Datos**  
El backend utiliza **Prisma ORM** para interactuar con PostgreSQL, asegurando consultas seguras y eficientes. A continuaci√≥n, se presentan ejemplos de c√≥mo se gestionan las principales entidades en la API:  

‚úÖ **Usuarios y Autenticaci√≥n con Supabase Auth**  
- Los usuarios se gestionan a trav√©s de **Supabase Auth (`AUTH_USERS`)**, y su perfil se almacena en `USERS`.  
- Se consulta el perfil de un usuario autenticado usando su **`auth_user_id`**.  

```typescript
const userProfile = await prisma.users.findUnique({
  where: { auth_user_id: auth.uid() },
});
```

‚úÖ **Consulta de Citas Agendadas por un Paciente**  
- Filtra las citas de un paciente autenticado.  

```typescript
const appointments = await prisma.appointments.findMany({
  where: { patient_id: auth.uid() },
  include: { professional: true },
});
```

‚úÖ **Validaci√≥n de Disponibilidad Antes de Agendar una Cita**  
- Se verifica que el horario no est√© reservado antes de confirmar una cita.  

```typescript
const isAvailable = await prisma.availability.findFirst({
  where: {
    professional_id: selectedProfessionalId,
    available_date: selectedDate,
    start_time: selectedTime,
    is_booked: false,
  },
});
```

‚úÖ **Notificaciones y Auditor√≠a**  
- Al registrar una acci√≥n importante, se almacena en `AUDIT_LOGS` con metadatos.  

```typescript
await prisma.audit_logs.create({
  data: {
    user_id: auth.uid(),
    action: "APPOINTMENT_BOOKED",
    metadata: { appointment_id: newAppointment.id },
  },
});
```

üìå **Estrategias de Optimizaci√≥n de Consultas**  
‚úÖ **Uso de √≠ndices en PostgreSQL** para acelerar b√∫squedas en `appointment_date` y `user_id`.  
‚úÖ **Carga selectiva de datos** con `include` en Prisma para evitar consultas innecesarias.  
‚úÖ **Paginaci√≥n en consultas grandes** con `take` y `skip` para evitar sobrecarga de datos en API.  

üìå **Resumen de la Implementaci√≥n**  
- El backend **mantiene la seguridad de datos** mediante **autenticaci√≥n con Supabase y reglas RLS**.  
- Se **optimiza el acceso a datos** con Prisma, asegurando consultas eficientes y evitando carga innecesaria.  
- Se emplean **logs de auditor√≠a y eventos internos** para registrar acciones cr√≠ticas.  


---

## **7.4 Diagrama de Secuencia**  

Este diagrama describe el proceso de **agendamiento de una cita**.  

```mermaid
sequenceDiagram
    participant Patient as Paciente
    participant Frontend as Frontend
    participant Backend as Backend API
    participant DB as Base de Datos
    participant Email as Servicio de Notificaciones

    Patient->>Frontend: Selecciona fecha y hora
    Frontend->>Backend: Env√≠a solicitud de agendamiento
    Backend->>DB: Valida disponibilidad
    DB-->>Backend: Respuesta de disponibilidad
    Backend->>DB: Guarda cita en la base de datos
    Backend->>Email: Env√≠a notificaci√≥n de confirmaci√≥n
    Email-->>Patient: Recibe confirmaci√≥n por correo
```

---

## **7.5 Diagrama de Flujo**  

```mermaid
graph TD;
    A[Profesional accede a la plataforma] --> B[Selecciona disponibilidad]
    B --> C{¬øEst√° disponible el horario?}
    C -- No --> D[Mostrar mensaje de error]
    C -- S√≠ --> E[Guardar disponibilidad en la base de datos]
    E --> F[Confirmaci√≥n enviada al profesional]
```

---

## **7.6 Dise√±o del Sistema y Arquitectura de Alto Nivel**  

El siguiente diagrama muestra la **arquitectura de alto nivel** del sistema, reflejando los principales componentes y sus interacciones.  

```mermaid
graph TD;
    subgraph Frontend
        A1[Next.js - UI Web]
    end
    
    subgraph Backend
        B1[NestJS - API REST]
        B2[Services Layer]
        B3[Domain Layer]
        B4[Infrastructure Layer]
    end
    
    subgraph Database
        C1[PostgreSQL]
    end
    
    subgraph External Services
        D1[Email Notification Service]
    end

    A1 -->|HTTP Requests| B1
    B1 -->|Business Logic| B2
    B2 -->|Domain Rules| B3
    B3 -->|Data Access| B4
    B4 -->|CRUD Operations| C1
    B1 -->|Triggers Notifications| D1
```

üìå **Explicaci√≥n:**  
- **Frontend (Next.js)**: Interfaz web para pacientes y profesionales.  
- **Backend (NestJS)**: Gestiona la l√≥gica de negocio y procesamiento de datos.  
- **Base de Datos (PostgreSQL)**: Almacena citas, disponibilidad y usuarios.  
- **Servicio Externo (Notificaciones)**: Maneja el env√≠o de correos electr√≥nicos.  

---


# **8. Integraciones y Dependencias Externas**  

### **8.1 Servicios de Correo Electr√≥nico**  

üìå **Estrategia de Implementaci√≥n**  
‚úÖ **Env√≠o As√≠ncrono de Correos**: Las notificaciones por correo electr√≥nico ser√°n procesadas a trav√©s de una **cola de eventos**, evitando bloqueos en la API.  
‚úÖ **Integraci√≥n con Supabase Auth**: Los correos se enviar√°n a los usuarios autenticados, garantizando seguridad y personalizaci√≥n del mensaje.  
‚úÖ **Proveedores de Correo Evaluados**:  
   - **SendGrid**: Opci√≥n recomendada por su integraci√≥n con NestJS.  
   - **Nodemailer**: Alternativa para entornos personalizados.  

üìå **Eventos que Disparan una Notificaci√≥n**  
‚úÖ **Confirmaci√≥n de Cita** (al agendar una nueva cita).  
‚úÖ **Recordatorios Autom√°ticos** (24 horas y 1 hora antes de la cita).  
‚úÖ **Modificaci√≥n o Cancelaci√≥n de Cita** (para notificar cambios a los usuarios).  
‚úÖ **Disponibilidad Modificada** (cuando un profesional cambia su horario).  

üìå **Ejemplo de Implementaci√≥n en Backend**  

```typescript
import * as nodemailer from "nodemailer";

const transporter = nodemailer.createTransport({
  service: "SendGrid",
  auth: {
    user: process.env.SENDGRID_USER,
    pass: process.env.SENDGRID_PASS,
  },
});

async function sendAppointmentConfirmation(email: string, appointmentDetails: object) {
  await transporter.sendMail({
    from: "no-reply@appointments.com",
    to: email,
    subject: "Cita Confirmada",
    text: `Tu cita ha sido confirmada para el ${appointmentDetails.date} a las ${appointmentDetails.time}`,
  });
}
```

üìå **Optimizaci√≥n y Seguridad**  
‚úÖ **Cola de Notificaciones con Redis o Supabase Storage**: Permite almacenar eventos pendientes de env√≠o.  
‚úÖ **Protecci√≥n contra Spam**: Limitaci√≥n de notificaciones enviadas por usuario en un per√≠odo determinado.  
‚úÖ **Monitoreo de Correos No Entregados**: Implementaci√≥n de m√©tricas para analizar tasa de √©xito en el env√≠o de correos.  

---

## **8.2 API Externas (Futuras Integraciones)**  

El MVP no incluir√° integraciones con servicios externos, pero se han definido puntos de extensi√≥n para futuras mejoras.  

üìå **Integraciones Evaluadas para Futuras Versiones:**  
‚úÖ **Calendarios Externos (Google Calendar, Outlook API):** Sincronizaci√≥n autom√°tica de citas.  
‚úÖ **Pasarelas de Pago (Stripe, PayPal):** Procesamiento de pagos online para consultas pagadas.  
‚úÖ **Mensajer√≠a (WhatsApp API, Twilio):** Recordatorios de citas mediante SMS o WhatsApp.  

üìå **Estrategia de Implementaci√≥n en Futuras Versiones:**  
- Se definir√°n **webhooks** para sincronizaci√≥n en tiempo real.  
- Se establecer√° una **capa de abstracci√≥n** para facilitar cambios en proveedores de servicio.  

---

## **8.3 Consideraciones para la Integraci√≥n de Calendarios**  

Para garantizar una integraci√≥n eficiente con **Google Calendar** o **Outlook API** en el futuro, se han definido los siguientes aspectos:  

üìå **Requisitos T√©cnicos:**  
‚úÖ Uso de **OAuth 2.0** para autenticaci√≥n de usuarios con sus cuentas de calendario.  
‚úÖ Implementaci√≥n de **webhooks** para actualizaciones en tiempo real.  
‚úÖ Conversi√≥n de citas del sistema a **eventos compatibles con el formato iCalendar**.  

üìå **Beneficios de la Integraci√≥n:**  
- Sincronizaci√≥n autom√°tica de las citas con calendarios personales.  
- Reducci√≥n de conflictos de agenda para profesionales.  

---


# **9. Plan de Despliegue e Infraestructura**  

## **9.1 Infraestructura y Entorno de Producci√≥n**  

El sistema ser√° desplegado en una infraestructura en la nube que garantice **alta disponibilidad, escalabilidad y seguridad**.  

üìå **Componentes de la Infraestructura:**  
‚úÖ **Frontend:** Desplegado en **Vercel** o **AWS S3 con CloudFront CDN** para optimizar la entrega de contenido.  
‚úÖ **Backend:** Desplegado en **AWS EC2, DigitalOcean o Render**, utilizando contenedores Docker.  
‚úÖ **Base de Datos:** **PostgreSQL en AWS RDS, Supabase o DigitalOcean Managed Databases** con backups autom√°ticos.  
‚úÖ **Servicio de Notificaciones:** Manejado con **SendGrid o AWS SES**.  
‚úÖ **Cache y Cola de Procesamiento:** Redis en AWS Elasticache o Upstash para mejorar rendimiento.  

üìå **Modelo de Implementaci√≥n:**  
- **Entorno de Desarrollo:** Local y staging en servidores temporales.  
- **Entorno de Producci√≥n:** Infraestructura gestionada con Docker + Kubernetes (en futuras versiones).  

---

### **9.2 Estrategia de Despliegue y CI/CD**  

üìå **Flujo de Despliegue Actualizado**  

1Ô∏è‚É£ **Commit en GitHub/GitLab:**  
   - Cada cambio en el c√≥digo se sube al repositorio.  
   - Se activan pruebas autom√°ticas antes del despliegue.  

2Ô∏è‚É£ **Pruebas Autom√°ticas en CI/CD:**  
   - **Pruebas unitarias y de integraci√≥n** con Jest y Cypress.  
   - **Verificaci√≥n de seguridad** en la API mediante OWASP ZAP.  

3Ô∏è‚É£ **Migraciones de Base de Datos en Supabase:**  
   - Se aplican cambios en el esquema con **Prisma Migrate**.  
   - Se actualizan las reglas **RLS (Row Level Security)** en Supabase.  

4Ô∏è‚É£ **Configuraci√≥n del Backend y Frontend:**  
   - Backend (NestJS) desplegado en **Render, AWS o DigitalOcean**.  
   - Frontend (Next.js) desplegado en **Vercel o AWS S3 con CloudFront CDN**.  
   - Configuraci√≥n de variables de entorno con **Supabase API Key** y JWT Secret.  

5Ô∏è‚É£ **Validaci√≥n en Staging:**  
   - Pruebas en un entorno pre-producci√≥n antes de lanzar cambios.  

6Ô∏è‚É£ **Promoci√≥n a Producci√≥n:**  
   - **Blue-Green Deployment**: Se activa la nueva versi√≥n sin interrumpir el servicio.  
   - Monitoreo en tiempo real con **Prometheus + Grafana**.  

üìå **Automatizaci√≥n de CI/CD con GitHub Actions (Ejemplo Backend)**  

```yaml
name: Deploy Backend
on:
  push:
    branches:
      - main
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "18"

      - name: Install Dependencies
        run: npm install
      
      - name: Run Tests
        run: npm test

      - name: Deploy to Render
        run: curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}
```

üìå **Seguridad en el Despliegue**  
‚úÖ **Reglas de seguridad en Supabase** para restringir accesos no autorizados.  
‚úÖ **Rotaci√≥n de claves API** en cada despliegue para evitar exposiciones.  
‚úÖ **Backups autom√°ticos** en la base de datos antes de aplicar migraciones.  


---

## **9.3 Mecanismos de Recuperaci√≥n ante Fallos**  

Para garantizar la estabilidad del sistema, se han definido estrategias de recuperaci√≥n en caso de fallos.  

üìå **Estrategias de Resiliencia:**  
‚úÖ **Backups Autom√°ticos:** Copias diarias de la base de datos con retenci√≥n configurable.  
‚úÖ **Rollback en Despliegues:** Implementaci√≥n de **feature flags** para deshacer cambios si se detectan errores.  
‚úÖ **Monitoreo Activo:** Uso de herramientas como **Prometheus + Grafana** o **AWS CloudWatch**.  
‚úÖ **Escalabilidad Autom√°tica:** Uso de **Auto Scaling Groups** en AWS para aumentar recursos en caso de alta demanda.  

üìå **Manejo de Errores y Recuperaci√≥n:**  
- **Errores Cr√≠ticos en Producci√≥n:** Reinicio autom√°tico con PM2 o Kubernetes.  
- **P√©rdida de Datos:** Restauraci√≥n desde backups en menos de 15 minutos.  
- **Ca√≠da del Servicio:** Redirecci√≥n de tr√°fico a servidores de respaldo.  

---


# **10. Decisiones Clave y Trade-offs**  

### **10.1 Justificaci√≥n de la Arquitectura Seleccionada**  

üìå **Decisiones Claves en la Arquitectura**  
‚úÖ **Uso de Supabase para autenticaci√≥n y base de datos**  
   - **Autenticaci√≥n gestionada con Supabase Auth**, lo que evita la implementaci√≥n manual de gesti√≥n de usuarios y seguridad.  
   - **PostgreSQL administrado en Supabase**, proporcionando **alta disponibilidad** sin la necesidad de mantenimiento manual.  

‚úÖ **Backend con NestJS + Prisma ORM**  
   - **Estructura modular** basada en **DDD y Clean Architecture** para escalabilidad.  
   - **Prisma ORM** permite una integraci√≥n optimizada con Supabase y PostgreSQL.  
   - **Middleware de autenticaci√≥n con Supabase JWT** para validar permisos en cada solicitud.  

‚úÖ **Frontend con Next.js**  
   - **Server-Side Rendering (SSR) y Static Generation (SSG)** para mejorar rendimiento.  
   - **Autenticaci√≥n gestionada con Supabase Auth**, eliminando la necesidad de almacenar credenciales localmente.  

‚úÖ **Colas de Procesamiento con Redis y Supabase Storage**  
   - **Procesamiento as√≠ncrono de notificaciones y auditor√≠a** para evitar bloqueos en la API.  
   - **Almacenamiento de logs y reportes en Supabase Storage** en lugar de sobrecargar la base de datos principal.  

üìå **Trade-offs Evaluados**  
| **Decisi√≥n** | **Alternativa Evaluada** | **Justificaci√≥n** |
|-------------|------------------------|------------------|
| **Supabase Auth** | Firebase Auth | Supabase ofrece integraci√≥n nativa con PostgreSQL y mejor control de RLS. |
| **PostgreSQL en Supabase** | AWS RDS | Supabase reduce la complejidad de administraci√≥n sin afectar escalabilidad. |
| **NestJS + Prisma** | Express + TypeORM | Prisma ofrece mejor tipado y compatibilidad con PostgreSQL. |
| **Next.js SSR** | React SPA | SSR mejora SEO y tiempos de carga iniciales. |

üìå **Beneficios Clave de la Arquitectura**  
‚úÖ **Reducci√≥n del tiempo de desarrollo** gracias a Supabase como backend-as-a-service.  
‚úÖ **Seguridad mejorada** con Supabase Auth y Row Level Security (RLS).  
‚úÖ **Escalabilidad autom√°tica** sin necesidad de administrar servidores de base de datos.  
‚úÖ **Menor costo operativo** al delegar infraestructura a Supabase en lugar de administrar bases de datos manualmente.  


---

## **10.2 Evaluaci√≥n de Alternativas Consideradas**  

| **Tecnolog√≠a / Enfoque** | **Alternativa Evaluada** | **Decisi√≥n Tomada** | **Justificaci√≥n** |
|--------------------------|------------------------|------------------|------------------|
| **Backend Framework** | Express.js | ‚ùå No Usado | NestJS ofrece mejor estructura y escalabilidad. |
| **Frontend Framework** | React (SPA) | ‚úÖ Usado (Next.js) | Next.js mejora SEO y performance con SSR. |
| **Base de Datos** | MySQL | ‚ùå No Usado | PostgreSQL tiene mejor soporte para JSON y transacciones. |
| **ORM** | TypeORM | ‚ùå No Usado | Prisma tiene mejor tipado y validaci√≥n de datos. |
| **Mensajer√≠a** | Kafka | üöß Evaluado para futuras versiones | RabbitMQ es m√°s adecuado para notificaciones y colas simples. |
| **Autenticaci√≥n** | Firebase Auth | üöß Evaluado para futuras versiones | Se planea implementar JWT/OAuth2 m√°s adelante. |

---

## **10.3 Aspectos a Mejorar en Futuras Iteraciones**  

El MVP se enfoca en la funcionalidad base del sistema, pero se han identificado mejoras para futuras versiones.  

üìå **√Åreas de mejora planeadas:**  
üöÄ **Implementaci√≥n de autenticaci√≥n (JWT / OAuth2)** para acceso seguro.  
üöÄ **Sincronizaci√≥n con calendarios externos (Google Calendar, Outlook)**.  
üöÄ **Soporte para pagos online (Stripe, PayPal, MercadoPago)**.  
üöÄ **Optimizaci√≥n del procesamiento de notificaciones con RabbitMQ**.  
üöÄ **Migraci√≥n a una arquitectura basada en eventos (Event-Driven Architecture)** para mejorar rendimiento en escalabilidad.  

---

# **11. Criterios de √âxito y Validaci√≥n**  

### **11.1 Definici√≥n de √âxito del MVP**  

üìå **Criterios de √âxito Funcional**  
‚úî **Los pacientes pueden agendar, modificar y cancelar citas sin errores.**  
‚úî **Los profesionales pueden gestionar su disponibilidad sin inconsistencias.**  
‚úî **El sistema env√≠a notificaciones autom√°ticas de confirmaci√≥n y recordatorio de citas.**  
‚úî **La autenticaci√≥n con Supabase Auth funciona correctamente, asegurando acceso basado en roles.**  

üìå **Criterios de Disponibilidad y Rendimiento (Ajustado para MVP)**  
‚úî **El sistema debe ser funcional durante los periodos de prueba y validaci√≥n, sin fallas cr√≠ticas prolongadas.**  
‚úî **El rendimiento debe ser suficiente para manejar pruebas con un n√∫mero limitado de usuarios concurrentes.**  
‚úî **No se establece un SLA estricto en esta fase, priorizando iteraciones y correcci√≥n de errores sobre disponibilidad continua.**  

üìå **Criterios de Seguridad y Validaci√≥n**  
‚úî **Las reglas RLS en Supabase deben garantizar que los usuarios solo accedan a sus propios datos.**  
‚úî **Se debe verificar que los JWT emitidos por Supabase sean correctamente validados en cada solicitud.**  
‚úî **No deben registrarse vulnerabilidades cr√≠ticas en las pruebas de seguridad.**  

üìå **Criterios de Experiencia del Usuario**  
‚úî **El 90% de los usuarios en la prueba beta deben completar el flujo de autenticaci√≥n y agendamiento sin problemas.**  
‚úî **El feedback de los usuarios debe reflejar una experiencia fluida y satisfactoria en la plataforma.**  
‚úî **Las notificaciones deben ser recibidas correctamente por los usuarios, sin errores en la entrega de correos.**  


---

### **11.2 Pruebas de Integraci√≥n y Carga**  

üìå **Tipos de Pruebas Aplicadas**  

| **Tipo de Prueba** | **Objetivo** | **Herramientas** |
|--------------------|-------------|-----------------|
| **Pruebas Unitarias** | Validar la l√≥gica de negocio en controladores y servicios. | Jest |
| **Pruebas de Integraci√≥n** | Verificar que la API interact√∫e correctamente con Supabase. | Jest + Supertest |
| **Pruebas de Seguridad** | Evaluar autenticaci√≥n con JWT y reglas RLS. | OWASP ZAP |
| **Pruebas de Carga** | Simular m√∫ltiples usuarios accediendo simult√°neamente al sistema. | k6 |
| **Pruebas de Concurrencia** | Verificar la gesti√≥n de disponibilidad en citas. | k6 + PostgreSQL Locks |

üìå **Estrategia de Pruebas en Supabase**  

‚úÖ **Validaci√≥n de Reglas de Seguridad (RLS)**  
- Se ejecutar√°n pruebas automatizadas para garantizar que **los pacientes solo accedan a sus propias citas**.  
- Se evaluar√°n restricciones en `AVAILABILITY` para evitar sobreescrituras indebidas de horarios de profesionales.  

‚úÖ **Autenticaci√≥n y Autorizaci√≥n con Supabase Auth**  
- Se probar√°n inicios de sesi√≥n con JWT y validaci√≥n de tokens.  
- Se evaluar√°n casos de **expiraci√≥n de sesiones** y reautenticaci√≥n con refresh tokens.  

‚úÖ **Carga Simult√°nea de Consultas a PostgreSQL**  
- Se probar√° el rendimiento de consultas como:  
  ```sql
  SELECT * FROM appointments WHERE patient_id = 'user-uuid' ORDER BY appointment_date DESC LIMIT 10;
  ```
- Se verificar√° la eficiencia de √≠ndices en `appointment_date` y `user_id`.  

üìå **Monitoreo en Entorno de Pruebas**  
‚úÖ **Supabase Logs**: Para analizar **tiempos de respuesta de autenticaci√≥n**.  
‚úÖ **Prometheus + Grafana**: Para visualizar carga en la API y la base de datos.  
‚úÖ **Sentry**: Para capturar errores en tiempo real durante pruebas de integraci√≥n.  


---

### **11.3 Estrategias de Validaci√≥n con Usuarios**  

üìå **Plan de Validaci√≥n con Usuarios Reales**  

‚úÖ **Prueba Beta con un grupo cerrado de profesionales y pacientes**  
   - Se seleccionar√°n usuarios reales para probar la plataforma en un entorno de **pre-producci√≥n**.  
   - Se registrar√° el feedback sobre la experiencia de autenticaci√≥n, navegaci√≥n y flujo de citas.  

‚úÖ **Verificaci√≥n de Permisos y Accesos**  
   - Se validar√° que **los pacientes solo puedan gestionar sus propias citas**.  
   - Se evaluar√° que **los profesionales solo puedan modificar su disponibilidad y ver sus citas asignadas**.  
   - Se analizar√° el correcto funcionamiento de las **reglas de seguridad RLS en Supabase**.  

‚úÖ **Pruebas de Autenticaci√≥n y Sesi√≥n**  
   - Evaluaci√≥n de inicio de sesi√≥n con Supabase Auth y validaci√≥n de JWT.  
   - Pruebas de persistencia de sesi√≥n y reautenticaci√≥n con refresh tokens.  
   - Pruebas de recuperaci√≥n de contrase√±a mediante Supabase Auth.  

‚úÖ **Evaluaci√≥n de Experiencia del Usuario**  
   - Se medir√° el tiempo promedio de **agendamiento de una cita** y **modificaci√≥n de disponibilidad**.  
   - Se recopilar√° retroalimentaci√≥n sobre **claridad de notificaciones y correos electr√≥nicos recibidos**.  
   - Se identificar√°n posibles **puntos de fricci√≥n en la interfaz** y se priorizar√°n mejoras.  

üìå **Herramientas para la Recopilaci√≥n de Feedback**  
‚úÖ **Hotjar o FullStory**: Para analizar el comportamiento del usuario en la interfaz.  
‚úÖ **Google Forms / Typeform**: Encuestas de satisfacci√≥n post-prueba.  
‚úÖ **Supabase Analytics**: Seguimiento de interacciones clave en la plataforma.  

üìå **Criterios de Aceptaci√≥n para la Validaci√≥n Final**  
‚úî **El 90% de los usuarios debe completar el flujo de autenticaci√≥n sin problemas.**  
‚úî **El sistema debe gestionar correctamente el acceso a citas y disponibilidad seg√∫n roles.**  
‚úî **Las pruebas de recuperaci√≥n de contrase√±a deben completarse sin errores.**  
‚úî **El feedback de usuarios debe reflejar una experiencia satisfactoria en navegaci√≥n y usabilidad.**  


---
